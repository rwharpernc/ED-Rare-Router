/**
 * EDDN Market Data Cache Reader
 * 
 * Reads real-time market data from the EDDN worker cache.
 * This provides up-to-date buy/sell prices and stock information.
 * 
 * The data file is generated by workers/eddn-worker.js
 * and is updated in real-time as EDDN messages are received.
 */

import { readFile } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";
import { getDataDir } from "./config";

const CACHE_FILE = join(getDataDir(), "eddnMarketCache.json");

/**
 * EDDN market update entry
 */
export interface EDDNMarketUpdate {
  timestamp: string;
  stock: number;
  stockBracket: number;
  buyPrice: number;
  sellPrice: number;
}

/**
 * EDDN cached market entry for a rare good
 */
export interface EDDNCachedMarketEntry {
  rare: string;
  system: string;
  station: string;
  updates: EDDNMarketUpdate[];
  latest?: {
    timestamp: string;
    stock: number;
    stockBracket: number;
    buyPrice: number;
    sellPrice: number;
  };
}

/**
 * EDDN cache structure
 */
export interface EDDNCache {
  _metadata?: {
    lastUpdated?: string;
    totalEntries?: number;
  };
  data?: Record<string, EDDNCachedMarketEntry>;
}

/**
 * Load EDDN market cache from disk
 */
export async function loadEDDNMarketCache(): Promise<EDDNCache | null> {
  try {
    if (!existsSync(CACHE_FILE)) {
      return null;
    }

    const content = await readFile(CACHE_FILE, "utf-8");
    const parsed = JSON.parse(content);
    
    // Handle deeply nested structure (worker bug creates nested structure)
    // Recursively unwrap until we find actual market data (not just _metadata)
    let current: any = parsed;
    let depth = 0;
    const maxDepth = 10; // Prevent infinite loops
    
    while (depth < maxDepth && current && typeof current === 'object') {
      // Check if current.data exists and is an object
      if (current.data && typeof current.data === 'object') {
        // Check if data contains actual market entries (has keys that look like "System|Station")
        const dataKeys = Object.keys(current.data);
        const hasMarketData = dataKeys.some(key => key.includes('|') && !key.startsWith('_'));
        
        if (hasMarketData) {
          // Found actual market data
          return {
            _metadata: current._metadata,
            data: current.data,
          };
        }
        
        // Check if nested deeper
        if (current.data.data && typeof current.data.data === 'object') {
          current = current.data;
          depth++;
          continue;
        }
        
        // This level has data but no market entries - might be empty or just metadata
        return {
          _metadata: current._metadata,
          data: current.data,
        };
      }
      
      // No data property, return what we have
      break;
    }
    
    // Fallback: return parsed as-is
    return parsed as EDDNCache;
  } catch (error) {
    console.error("[EDDN Market Cache] Error loading cache:", error);
    return null;
  }
}

/**
 * Get market data for a specific rare good by system and station
 */
export async function getEDDNMarketData(
  system: string,
  station: string
): Promise<EDDNCachedMarketEntry | null> {
  const cache = await loadEDDNMarketCache();
  if (!cache || !cache.data) {
    return null;
  }

  const key = `${system}|${station}`;
  const entry = cache.data[key];
  
  // Debug logging
  if (!entry) {
    console.debug(`[EDDN Cache] No data for key: ${key}`);
    console.debug(`[EDDN Cache] Available keys: ${Object.keys(cache.data).slice(0, 5).join(', ')}...`);
  }
  
  return entry || null;
}

/**
 * Get market data for a specific rare good by name
 */
export async function getEDDNRareGoodData(
  rareName: string
): Promise<EDDNCachedMarketEntry | null> {
  const cache = await loadEDDNMarketCache();
  if (!cache || !cache.data) {
    return null;
  }

  // Search for the rare good by name
  for (const key in cache.data) {
    const entry = cache.data[key];
    if (entry.rare.toLowerCase() === rareName.toLowerCase()) {
      return entry;
    }
  }

  return null;
}

/**
 * Get all cached EDDN market data
 */
export async function getAllEDDNMarketData(): Promise<
  Record<string, EDDNCachedMarketEntry>
> {
  const cache = await loadEDDNMarketCache();
  if (!cache || !cache.data) {
    return {};
  }

  return cache.data;
}
