/**
 * EDSM Market Data Cache Reader
 * 
 * Reads bulk-fetched market data from the local JSON file.
 * This avoids API calls on every request and works with Netlify.
 * 
 * The data file is generated by scripts/fetch-edsm-market-data.js
 * and should be updated every 12 hours (via CI/CD or manual run).
 */

import { readFile } from "fs/promises";
import { existsSync } from "fs";
import { join } from "path";

const CACHE_FILE = join(process.cwd(), "data", "edsmMarketData.json");

/**
 * Commodity data from EDSM
 */
export interface EDSMCachedCommodity {
  name: string;
  buyPrice: number;
  sellPrice: number;
  stock: number;
  stockBracket: number;
  demand: number;
  demandBracket: number;
}

/**
 * Cached market entry for a rare good
 */
export interface EDSMCachedMarketEntry {
  rare: string;
  system: string;
  station: string;
  timestamp: string;
  commodity?: EDSMCachedCommodity;
  allCommodities?: EDSMCachedCommodity[];
}

/**
 * Cache metadata
 */
export interface EDSMCacheMetadata {
  fetchedAt: string;
  totalRares: number;
  fetchedCount: number;
  successCount: number;
  errorCount: number;
  skippedCount: number;
}

/**
 * Full cache structure
 */
export interface EDSMCache {
  _metadata: EDSMCacheMetadata;
  data: Record<string, EDSMCachedMarketEntry>;
}

/**
 * Load EDSM market cache from disk
 */
export async function loadEDSMMarketCache(): Promise<EDSMCache | null> {
  try {
    if (!existsSync(CACHE_FILE)) {
      return null;
    }

    const content = await readFile(CACHE_FILE, "utf-8");
    const cache: EDSMCache = JSON.parse(content);
    return cache;
  } catch (error) {
    console.error("[EDSM Market Cache] Error loading cache:", error);
    return null;
  }
}

/**
 * Get market data for a specific rare good by system and station
 */
export async function getCachedMarketData(
  system: string,
  station: string
): Promise<EDSMCachedMarketEntry | null> {
  const cache = await loadEDSMMarketCache();
  if (!cache || !cache.data) {
    return null;
  }

  const key = `${system}|${station}`;
  return cache.data[key] || null;
}

/**
 * Get market data for a specific rare good by name
 */
export async function getCachedRareGoodData(
  rareName: string
): Promise<EDSMCachedMarketEntry | null> {
  const cache = await loadEDSMMarketCache();
  if (!cache || !cache.data) {
    return null;
  }

  // Find by rare name
  for (const entry of Object.values(cache.data)) {
    if (entry.rare.toLowerCase() === rareName.toLowerCase()) {
      return entry;
    }
  }

  return null;
}

/**
 * Get all cached market data
 */
export async function getAllCachedMarketData(): Promise<
  Record<string, EDSMCachedMarketEntry>
> {
  const cache = await loadEDSMMarketCache();
  if (!cache || !cache.data) {
    return {};
  }

  return cache.data;
}

/**
 * Get cache metadata (last fetched time, etc.)
 */
export async function getCacheMetadata(): Promise<EDSMCacheMetadata | null> {
  const cache = await loadEDSMMarketCache();
  return cache?._metadata || null;
}

/**
 * Check if cache data is fresh (within 12 hours)
 */
export async function isCacheFresh(): Promise<boolean> {
  const metadata = await getCacheMetadata();
  if (!metadata || !metadata.fetchedAt) {
    return false;
  }

  const fetchedDate = new Date(metadata.fetchedAt);
  const hoursSinceFetch = (Date.now() - fetchedDate.getTime()) / (1000 * 60 * 60);
  return hoursSinceFetch < 12;
}
