/**
 * EDDN Worker Service - Simple File-Based Cache Version
 * 
 * This worker connects to EDDN via ZeroMQ and caches rare goods market data
 * to a JSON file. The Astro API can then read from this cache.
 * 
 * Run this as a separate process: node workers/eddn-worker.js
 * 
 * For production, consider using PM2 or similar process manager.
 */

import { Subscriber } from 'zeromq';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { inflate } from 'zlib';
import { promisify } from 'util';

const inflateAsync = promisify(inflate);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// EDDN Relay endpoint
const EDDN_RELAY = 'tcp://eddn.edcd.io:9500';

// Cache file path (relative to project root)
const CACHE_FILE = join(__dirname, '..', 'data', 'eddnMarketCache.json');

// Rare goods stations to monitor (system + station name)
// This will be populated from rares.ts data
const RARE_STATIONS = new Map(); // Will be loaded from rares.ts

// Market data cache
let marketCache = {};

// Load rare stations from rares.json (generated by export script)
async function loadRareStations() {
  try {
    const raresPath = join(__dirname, '..', 'data', 'rares.json');
    
    if (!existsSync(raresPath)) {
      console.warn('[EDDN Worker] rares.json not found. Run: node scripts/export-rares-json.js');
      console.warn('[EDDN Worker] Continuing without rare station filtering (will process all market data)');
      return;
    }
    
    const content = await readFile(raresPath, 'utf-8');
    const rares = JSON.parse(content);
    
    if (!Array.isArray(rares)) {
      throw new Error('rares.json must contain an array');
    }
    
    rares.forEach(rare => {
      const key = `${rare.system}|${rare.station}`;
      RARE_STATIONS.set(key, {
        rare: rare.rare,
        system: rare.system,
        station: rare.station,
      });
    });
    
    console.log(`[EDDN Worker] Loaded ${RARE_STATIONS.size} rare goods stations to monitor`);
  } catch (error) {
    console.error('[EDDN Worker] Error loading rare stations:', error);
    console.error('[EDDN Worker] Run: node scripts/export-rares-json.js to generate rares.json');
    // Don't exit - continue with empty map (will just not filter)
  }
}

// Load existing cache from disk
async function loadCache() {
  try {
    if (existsSync(CACHE_FILE)) {
      const data = await readFile(CACHE_FILE, 'utf-8');
      const parsed = JSON.parse(data);
      
      // Handle nested structure if it exists (from previous bug)
      if (parsed.data && typeof parsed.data === 'object' && parsed.data.data) {
        // Unwrap nested data
        marketCache = parsed.data.data;
      } else if (parsed.data) {
        // Normal structure
        marketCache = parsed.data;
      } else {
        // Old format (no wrapper)
        marketCache = parsed;
      }
      
      // Ensure marketCache is an object, not nested
      if (!marketCache || typeof marketCache !== 'object' || Array.isArray(marketCache)) {
        marketCache = {};
      }
      
      console.log(`[EDDN Worker] Loaded cache with ${Object.keys(marketCache).length} entries`);
    } else {
      marketCache = {};
      console.log('[EDDN Worker] Starting with empty cache');
    }
  } catch (error) {
    console.error('[EDDN Worker] Error loading cache:', error);
    marketCache = {};
  }
}

// Save cache to disk
async function saveCache() {
  try {
    // Ensure data directory exists
    const dataDir = join(__dirname, '..', 'data');
    if (!existsSync(dataDir)) {
      await mkdir(dataDir, { recursive: true });
    }
    
    // Add metadata
    const cacheWithMetadata = {
      _metadata: {
        lastUpdated: new Date().toISOString(),
        totalEntries: Object.keys(marketCache).length,
      },
      data: marketCache,
    };
    
    await writeFile(CACHE_FILE, JSON.stringify(cacheWithMetadata, null, 2), 'utf-8');
    console.log(`[EDDN Worker] Saved cache with ${Object.keys(marketCache).length} entries`);
  } catch (error) {
    console.error('[EDDN Worker] Error saving cache:', error);
  }
}

// Process EDDN market message
async function processMarketMessage(message) {
  try {
    if (!message) {
      console.warn('[EDDN Worker] Received undefined message');
      return;
    }
    
    // EDDN messages are zlib-compressed
    // First, ensure we have a Buffer
    const messageBuffer = Buffer.isBuffer(message) ? message : Buffer.from(message);
    
    // Decompress the message
    let decompressed;
    try {
      decompressed = await inflateAsync(messageBuffer);
    } catch (error) {
      // If decompression fails, try parsing as plain JSON (some messages might not be compressed)
      try {
        const messageStr = messageBuffer.toString('utf-8');
        decompressed = Buffer.from(messageStr, 'utf-8');
      } catch (e) {
        console.warn('[EDDN Worker] Failed to decompress message:', error.message);
        return;
      }
    }
    
    // Parse JSON from decompressed buffer
    const messageStr = decompressed.toString('utf-8');
    if (!messageStr) {
      console.warn('[EDDN Worker] Decompressed message is empty');
      return;
    }
    
    const data = JSON.parse(messageStr);
    
    // Check if this is a market message
    if (!data.message || !data.message.commodities) {
      return;
    }
    
    const systemName = data.message.systemName;
    const stationName = data.message.stationName;
    const key = `${systemName}|${stationName}`;
    
    // Check if this is a rare goods station
    if (!RARE_STATIONS.has(key)) {
      // Silently skip non-rare stations (too many messages to log)
      return;
    }
    
    const rareInfo = RARE_STATIONS.get(key);
    const timestamp = data.message.timestamp || data.header?.timestamp || new Date().toISOString();
    
    // Find rare goods in the commodities list
    const rareCommodities = data.message.commodities.filter(
      commodity => commodity.name === rareInfo.rare
    );
    
    if (rareCommodities.length > 0) {
      const commodity = rareCommodities[0];
      
      // Store market data
      if (!marketCache[key]) {
        marketCache[key] = {
          rare: rareInfo.rare,
          system: systemName,
          station: stationName,
          updates: [],
        };
      }
      
      // Add update entry
      marketCache[key].updates.push({
        timestamp,
        stock: commodity.stock || 0,
        stockBracket: commodity.stockBracket || 0,
        buyPrice: commodity.buyPrice || 0,
        sellPrice: commodity.sellPrice || 0,
      });
      
      // Keep only last 10 updates per station
      if (marketCache[key].updates.length > 10) {
        marketCache[key].updates = marketCache[key].updates.slice(-10);
      }
      
      // Update latest data
      marketCache[key].latest = {
        timestamp,
        stock: commodity.stock || 0,
        stockBracket: commodity.stockBracket || 0,
        buyPrice: commodity.buyPrice || 0,
        sellPrice: commodity.sellPrice || 0,
      };
      
      // Log detailed notification
      console.log(`[EDDN Worker] ✓ Updated: ${rareInfo.rare} at ${systemName}/${stationName}`);
      console.log(`  Stock: ${commodity.stock || 0} (Bracket: ${commodity.stockBracket || 0}) | Buy: ${commodity.buyPrice || 0} | Sell: ${commodity.sellPrice || 0}`);
      
      // Save cache periodically (debounced)
      scheduleCacheSave();
    } else {
      // Rare goods station found, but rare good not in commodities
      // This could mean: out of stock, name mismatch, or not included in this update
      const commodityCount = data.message.commodities?.length || 0;
      const commodityNames = data.message.commodities?.slice(0, 5).map(c => c.name).join(', ') || 'none';
      const moreCommodities = commodityCount > 5 ? ` (+${commodityCount - 5} more)` : '';
      
      console.log(`[EDDN Worker] ⚠ ${rareInfo.rare} station ${systemName}/${stationName} updated`);
      console.log(`  Looking for: "${rareInfo.rare}"`);
      console.log(`  Market has ${commodityCount} commodities: ${commodityNames}${moreCommodities}`);
      console.log(`  Note: Rare good may be out of stock, or name may not match exactly`);
    }
  } catch (error) {
    console.error('[EDDN Worker] Error processing message:', error);
  }
}

// Debounced cache save
let saveTimer = null;
function scheduleCacheSave() {
  if (saveTimer) {
    clearTimeout(saveTimer);
  }
  
  // Save after 30 seconds of inactivity
  saveTimer = setTimeout(() => {
    saveCache();
    saveTimer = null;
  }, 30000);
}

// Main worker function
async function startWorker() {
  console.log('[EDDN Worker] Starting EDDN worker service...');
  
  // Load rare stations
  await loadRareStations();
  
  // Load existing cache
  await loadCache();
  
  // Create ZeroMQ subscriber (v6 API uses classes)
  const subscriber = new Subscriber();
  
  // Connect to EDDN relay
  await subscriber.connect(EDDN_RELAY);
  console.log(`[EDDN Worker] Connected to EDDN relay: ${EDDN_RELAY}`);
  
  // Subscribe to all messages (EDDN doesn't use topic filtering)
  subscriber.subscribe('');
  
  // Handle incoming messages (v6 API uses async iteration)
  (async () => {
    try {
      for await (const frames of subscriber) {
        // ZeroMQ v6 returns frames as an array or single frame
        // EDDN sends messages as: [topic, message] where topic is empty string
        let message;
        if (Array.isArray(frames)) {
          // If array, message is typically the last frame
          message = frames[frames.length - 1];
          // Debug: log frame structure on first message
          if (frames.length > 0 && !Buffer.isBuffer(frames[0])) {
            console.log('[EDDN Worker] Debug: frames structure:', {
              length: frames.length,
              types: frames.map(f => typeof f),
              firstFrame: frames[0]
            });
          }
        } else {
          // If single frame, use it directly
          message = frames;
        }
        
        if (!message) {
          console.warn('[EDDN Worker] Received message with no data, frames:', frames);
          continue;
        }
        
        // message is a Buffer, EDDN messages are zlib-compressed
        // processMarketMessage will handle decompression
        await processMarketMessage(message);
      }
    } catch (error) {
      if (error.message !== 'Socket is closed') {
        console.error('[EDDN Worker] ZeroMQ error:', error);
      }
    }
  })();
  
  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\n[EDDN Worker] Shutting down...');
    await subscriber.close();
    await saveCache();
    process.exit(0);
  });
  
  process.on('SIGTERM', async () => {
    console.log('\n[EDDN Worker] Shutting down...');
    await subscriber.close();
    await saveCache();
    process.exit(0);
  });
  
  // Periodic cache save (every 5 minutes)
  setInterval(() => {
    saveCache();
  }, 5 * 60 * 1000);
  
  console.log('[EDDN Worker] Worker started and listening for EDDN messages');
}

// Start the worker
startWorker().catch((error) => {
  console.error('[EDDN Worker] Fatal error:', error);
  process.exit(1);
});
